{
    "summary": "This code defines a class `ErrorManager` for error and exception handling, offering methods to manage errors, format messages, handle exceptions with `__enter__` and `__exit__`, and includes special method implementations and an iterable implementation.",
    "details": [
        {
            "comment": "This code defines a class called ErrorManager which handles exceptions and errors. It can be used in with statements to automate exception management, and its behavior can be configured using suppress_error, suppress_exception, and default_error arguments.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/error_utils.py\":0-34",
            "content": "from log_utils import logger_print\n# from beartype import beartype\nfrom typing import Union\nimport traceback\nimport sys\n# @beartype\nclass ErrorManager:\n    \"\"\"\n    Manage exceptions and errors.\n    Can be used in `with` statements to automate such management, which behavior can be configured by setting `suppress_error` and `suppress_exception` arguments.\n    Args:\n    suppress_error:bool: If suppressed, don't raise exception if having error messages\n    suppress_exception:bool: If suppressed, don't suppress exception raised by program\n    default_error:str: The default error message to display if any error occurs during execution\n    \"\"\"\n    def __init__(\n        self,\n        suppress_error: bool = False,\n        suppress_exception: bool = False,\n        default_error: Union[str, None] = None,\n    ):\n        self.errors = []\n        self.suppress_error = suppress_error\n        self.suppress_exception = suppress_exception\n        self.default_error = default_error\n    def __bool__(self):\n        return len(self.errors) > 0"
        },
        {
            "comment": "This code defines a class for handling errors and exceptions. It provides properties to check if there are any errors or exceptions, a method to append new error messages, clear the list of errors, format error messages, raise an exception if there are any errors, print errors if they exist, and implement `__enter__` and `__exit__` methods for exception handling.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/error_utils.py\":36-77",
            "content": "    @property\n    def has_error(self):\n        return bool(self)\n    @property\n    def has_exception(self):\n        last_exc = sys.exc_info()\n        return last_exc[0] is not None\n    def append(self, error: str):\n        self.errors.append(error)\n    def clear(self):\n        self.errors = []\n        self.default_error = None\n    def format_error(self, clear=True, join: str = \"\\n\"):\n        error_msg = join.join(\n            self.errors\n            + ([self.default_error] if (self and self.default_error) else [])\n        )\n        if clear:\n            self.clear()\n        return error_msg\n    def raise_if_any(self):\n        if self.errors:\n            self.print_if_any()\n            raise Exception(self.format_error())\n    def print_if_any(self):\n        if self.errors:\n            logger_print(self.format_error())\n            return True\n        return False\n    def __enter__(self):\n        self.raise_if_any()\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is None and not self.suppress_error:"
        },
        {
            "comment": "This code defines a class `ErrorManager` that handles errors and exceptions. It provides methods to append errors, raise if any errors are present, print if any errors are present, and handle exception tracebacks. The code also includes special method implementations for `__str__`, `__repr__`, and `__len__` for error management. Finally, it has an iterable implementation (`__iter__`) and a test case in the `if __name__ == \"__main__\":` block.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/error_utils.py\":78-105",
            "content": "            self.raise_if_any()\n        else:\n            self.print_if_any()\n        if self.has_exception:\n            traceback_exc = traceback.format_exc()\n            logger_print(traceback_exc)\n        return True if self.suppress_exception else None\n    def __str__(self):\n        return self.format_error(clear=False)\n    def __repr__(self):\n        return self.format_error(clear=False)\n    def __len__(self):\n        return len(self.errors)\n    def __iter__(self):\n        return iter(self.errors)\nif __name__ == \"__main__\":\n    # test this!\n    with ErrorManager() as em:\n        # raise Exception(\"before append\")\n        em.append('abc')\n        raise Exception(\"after append\")"
        }
    ]
}