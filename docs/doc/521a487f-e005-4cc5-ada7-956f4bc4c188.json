{
    "summary": "The code sets up a custom logger with rotating file handlers, stream handlers, and timezone-aware datetime objects for better exception handling and improved readability. It also prints messages based on conditions and runs a test loop for debugging purposes.",
    "details": [
        {
            "comment": "Code imports necessary libraries, sets up variables for terminal column size and minimum Python version, and checks if the current Python version is supported. If not, it raises a warning with an import statement and defines some log formatting functions.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/log_utils.py\":0-39",
            "content": "\"\"\"\nTo use 'managed' loggers, you must import 'logger' from this file and pass it to other code.\n\"\"\"\n# TODO: top-level exception hook (sys.excepthook)\n# TODO: configure file handlers for celery logging\n# TODO: find a tool or make some script to take input from stdin and log & filter output\nfrom rich.pretty import pretty_repr\ndef pretty(obj):\n    return pretty_repr(obj)\n# python version check\nimport sys  # recommend: 3.11.2\nimport os\ntry:\n    terminal_column_size = os.get_terminal_size().columns\nexcept:\n    terminal_column_size = 30\nMIN_PY_VERSION = (3, 8)\nSHOW_PYTHON_VERSION_WARNING = False\n# TODO; make lower version of python supports logging utils\nif sys.version_info < MIN_PY_VERSION:\n    SHOW_PYTHON_VERSION_WARNING = True\n    import inspect\n    from exceptional_print import exprint\n    FORMAT = \"%(asctime)s <%(name)s:%(levelname)s> %(callerInfo)s\\n%(message)s\"\n    SHORT_FORMAT = \"%(asctime)s <%(name)s:%(levelname)s> %(callerInfo)s\\n%(short_msg)s\"\n    def get_caller_info(level: int = 2):\n        assert level >= 2, f\"level {level} less than 2\""
        },
        {
            "comment": "This code snippet is getting the function name, line number, and file path of the caller frame (the function that called this one) by walking up the stack until it reaches the top level. It then uses this information to format a log message using a custom logging format.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/log_utils.py\":40-62",
            "content": "        caller_frame = inspect.currentframe().f_back\n        for _ in range(level - 1):\n            caller_frame = caller_frame.f_back\n        # breakpoint()\n        code_filename = caller_frame.f_code.co_filename\n        code_relpath = os.path.relpath(code_filename)\n        caller_info = \"['%s:%s' - %s()]\" % (\n            code_relpath,\n            caller_frame.f_lineno,\n            caller_frame.f_code.co_name,\n        )\n        # exlogger_print(caller_info.center(60, \"+\"))\n        # exlogger_print(*args, *[f\"{k}:\\t{v}\" for k, v in kwargs.items()], sep=os.linesep)\n        return caller_info\nelse:\n    FORMAT = (  # add timestamp.\n        \"%(asctime)s <%(name)s:%(levelname)s> ['%(pathname)s:%(lineno)s' - %(funcName)s()]\\n%(message)s\"  # miliseconds already included!\n        # \"%(asctime)s.%(msecs)03d <%(name)s:%(levelname)s> [%(pathname)s:%(lineno)s - %(funcName)s()]\\n%(message)s\"\n        # \"<%(name)s:%(levelname)s> [%(pathname)s:%(lineno)s - %(funcName)s()]\\n%(message)s\"\n    )\n    SHORT_FORMAT = \"%(asctime)s <%(name)s:%(levelname)s> ['%(pathname)s:%(lineno)s' - %(funcName)s()]\\n%(short_msg)s\""
        },
        {
            "comment": "This code initializes logger locks, sets global variables for logging and huge message thresholds, and schedules periodic refreshes of the logger locks. It also includes a logging filter function, but it is currently commented out.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/log_utils.py\":64-104",
            "content": "# TODO: use `code_checker.py` to insert `log_utils` dependency to every py file under this folder. except for this one!\nimport logging\nimport schedule\n# import traceback\n# from exceptional_print import exprint as ep\nimport better_exceptions\n# ft = logging.Filter(\"myfilter\") # default filter is just a string checker\nallow_logging = True\nallow_huge_logging = True\nHUGE_MSG_THRESHOLD = 100\ndef refresh_logger_lock():\n    global allow_logging\n    allow_logging = True\ndef refresh_huge_logger_lock():\n    global allow_huge_logging\n    allow_huge_logging = True\nschedule.every(0.3).seconds.do(refresh_logger_lock)\nschedule.every(1).seconds.do(refresh_huge_logger_lock)\n# class MessageLengthAndFrequencyFilter:\n#     @staticmethod\ndef messageLengthAndFrequencyFilter(record: logging.LogRecord):\n    # def filter(record: logging.LogRecord):\n    global allow_logging, allow_huge_logging, HUGE_MSG_THRESHOLD\n    schedule.run_pending()\n    # logger_print(dir(record))\n    accepted = False\n    # msg = record.msg\n    # shall you intercept the args..."
        },
        {
            "comment": "This code initializes a log file handler for a logging module and handles the formatting of log messages based on their length. It also checks if the required directory for storing logs exists and creates it if not.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/log_utils.py\":105-139",
            "content": "    # args = record.args # tuple. let's reset it.\n    # breakpoint()\n    msg = record.msg = record.msg % record.args\n    setattr(record, \"short_msg\", msg)\n    args = record.args = ()\n    if len(msg) < HUGE_MSG_THRESHOLD:\n        if allow_logging:  # then this is some short message.\n            accepted = True\n            allow_logging = False\n    else:\n        if allow_huge_logging:\n            record.short_msg = \" \".join(\n                [msg[:HUGE_MSG_THRESHOLD], \"...\"]\n            )  # do not put stdout in front of file handler!\n            accepted = True\n            allow_huge_logging = False\n    return accepted\nfrom logging import StreamHandler\nlog_dir = os.path.join(os.path.dirname(__file__), \"logs\")\nif os.path.exists(log_dir):\n    if not os.path.isdir(log_dir):\n        raise Exception(\n            f\"Non-directory object taking place of log directory `{log_dir}`.\"\n        )\nelse:\n    # os.system(f\"mkdir -p {log_dir}\")\n    os.mkdir(log_dir)\nlog_filename = os.path.join(log_dir, \"debug.log\")\ncelery_log_filename = os.path.join(log_dir, \"celery.log\")"
        },
        {
            "comment": "This code sets up a custom logging formatter that uses timezone-aware datetime objects. It creates a RotatingFileHandler for the \"fastapi.log\" file and configures it with two different formatters: one for a full log format and another for a shorter log format. The script also imports necessary modules like os, pytz, logging, and datetime.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/log_utils.py\":140-176",
            "content": "fastapi_log_filename = os.path.join(log_dir, \"fastapi.log\")\nfrom logging.handlers import RotatingFileHandler\nimport pytz\n# with respect to our dearly Py3.6\ntimezone_str = \"Asia/Shanghai\"\n# timezone = pytz.timezone(timezone_str:='Asia/Shanghai')\ntimezone = pytz.timezone(timezone_str)\n# import logging\nimport datetime\nclass Formatter(logging.Formatter):\n    \"\"\"override default 'logging.Formatter' to use timezone-aware datetime object\"\"\"\n    def converter(self, timestamp):\n        # Create datetime in UTC\n        dt = datetime.datetime.fromtimestamp(timestamp, tz=pytz.UTC)\n        # Change datetime's timezone\n        return dt.astimezone(timezone)\n    def formatTime(self, record, datefmt=None):\n        dt = self.converter(record.created)\n        if datefmt:\n            s = dt.strftime(datefmt)\n        else:\n            try:\n                s = dt.isoformat(timespec=\"milliseconds\")\n            except TypeError:\n                s = dt.isoformat()\n        return s\nmyFormatter = Formatter(fmt=FORMAT)\nmyShortFormatter = Formatter(fmt=SHORT_FORMAT)"
        },
        {
            "comment": "This code sets up a logging system with a rotating file handler for log files and a stream handler for stdout. It defines a makeRotatingFileHandler function that creates the RotatingFileHandler instance and configures it with maximum size and backup count. The logger is created using the specified name, set to DEBUG level, and has both the file and stdout handlers added.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/log_utils.py\":179-204",
            "content": "def makeRotatingFileHandler(log_filename: str, level=logging.DEBUG):\n    myHandler = RotatingFileHandler(\n        log_filename, maxBytes=1024 * 1024 * 15, backupCount=3, encoding=\"utf-8\"\n    )\n    myHandler.setLevel(level)\n    myHandler.setFormatter(myFormatter)\n    return myHandler\nmyHandler = makeRotatingFileHandler(log_filename)\n# myHandler.setLevel(logging.INFO) # will it log less things? yes.\n# FORMAT = \"<%(name)s:%(levelname)s> [%(filename)s:%(lineno)s - %(funcName)s() ] %(message)s\"\n# myFormatter = logging.Formatter(fmt=FORMAT)\n# myHandler.setFormatter(myFormatter)\nstdout_handler = StreamHandler(sys.stdout)  # test with this!\nstdout_handler.setLevel(logging.DEBUG)\n# stdout_handler.addFilter(MessageLengthAndFrequencyFilter)\nstdout_handler.addFilter(messageLengthAndFrequencyFilter)  # method also works!\nstdout_handler.setFormatter(myShortFormatter)\n# do not use default logger!\n# logger = logging.getLogger(__name__)\nlogger = logging.getLogger(\"microgrid\")\nlogger.setLevel(\"DEBUG\")\nlogger.addHandler(myHandler)  # BUG: make sure long logs are unaffected in file."
        },
        {
            "comment": "Logger setup and function to print formatted log messages with optional stack trace information.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/log_utils.py\":205-233",
            "content": "logger.addHandler(stdout_handler)\ndef logger_print(*args, logger=logger, stacklevel = 2):\n    if len(args) != 0:\n        format_string = \"\\n\\n\".join([\"%s\"] * len(args))\n        # python 3.8+ required!\n        logger.debug(\n            format_string,\n            *[\n                # fallback for older versions:\n                pretty(arg)\n                if not any(isinstance(arg, t) for t in [bytes, str])\n                else arg\n                # pretty_repr(arg) if not isinstance(arg, Union[bytes, str]) else arg\n                for arg in args\n            ],\n            **(\n                {\"stacklevel\": stacklevel}\n                if not SHOW_PYTHON_VERSION_WARNING\n                else {\"extra\": {\"callerInfo\": get_caller_info(level = stacklevel)}}\n            ),\n        )  # it is been called elsewhere.\n        # logger.debug(\n        #     \"\\n\\n\".join([pretty_repr(arg) if not isinstance(arg, Union[bytes, str]) else arg for arg in args]), stacklevel=2\n        # )  # it is been called elsewhere.\nimport datetime"
        },
        {
            "comment": "Setting up custom exception handling and logging configuration for better readability.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/log_utils.py\":235-265",
            "content": "logger_print(\n    f\"[START LOGGING AT: {datetime.datetime.now().isoformat()}]\".center(\n        terminal_column_size, \"+\"\n    )\n    # f\"[START LOGGING AT: {datetime.datetime.now().isoformat()}]\".center(70 - 2, \"+\")\n)\n# logging.basicConfig(\n#     # filename=filename,\n#     # level=logging.getLogger().getEffectiveLevel(),\n#     level=\"DEBUG\",\n#     # stream=sys.stderr\n#     force=True, # overridding root logger, which is deprecated.\n#     handlers=[stdout_handler],\n# )\ndef logger_excepthook(exc_type, exc_value, tb):\n    with pretty_format_excinfo_context(exc_type, exc_value, tb) as formatted:\n        formatted_exc = [\"<TOPLEVEL EXCEPTION>\", formatted]\n        logger_print(*formatted_exc)\n    better_exceptions.excepthook(exc_type, exc_value, tb)\nfrom contextlib import contextmanager\n@contextmanager\ndef pretty_format_excinfo_context(exc_type, exc_value, tb):\n    try:\n        better_exceptions.SUPPORTS_COLOR = False\n        formatted = \"\".join(better_exceptions.format_exception(exc_type, exc_value, tb))\n        yield formatted"
        },
        {
            "comment": "This code sets up a logger for printing tracebacks, changes sys.excepthook to use this logger, and prints messages for various conditions. It also runs a test loop that logs debug messages.\n\nCode functionality: \nThe code sets the 'better_exceptions.SUPPORTS_COLOR' variable to True. It defines the 'logger_traceback_print' function which uses the context manager 'pretty_format_excinfo_context' to format an exception traceback and logs it with 'logger_print'. The 'sys.excepthook' is set to 'logger_excepthook' so that exceptions are logged using this logger. Finally, it prints a message indicating the start of logging at the current directory and a warning if the Python version is below a certain minimum level. If run as main script, it runs a loop which logs debug messages.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/log_utils.py\":266-287",
            "content": "    finally:\n        better_exceptions.SUPPORTS_COLOR = True\ndef logger_traceback_print():\n    with pretty_format_excinfo_context(*sys.exc_info()) as formatted:\n        logger_print(formatted, stacklevel = 3)\nsys.excepthook = logger_excepthook\nlogger_print(\"logging started at directory: \", os.path.abspath(os.curdir))\nif SHOW_PYTHON_VERSION_WARNING:\n    logger_print(\n        f\"Please use Python {'.'.join([str(v) for v in MIN_PY_VERSION])} and above.\"\n    )\nif __name__ == \"__main__\":  # just a test.\n    import time\n    for i in range(100):\n        time.sleep(0.1)\n        logger.debug(f\"test debug message {i}\")\n        logger.debug(f\"test debug message {i} %s\", \"myarg\")\n        logger.debug(f\"test huge message {i} \" * 100)  # huge mssage"
        }
    ]
}