{
    "summary": "The \"ArgumentTransformer\" class converts data model annotations to command line arguments, stores properties for further processing, and handles errors. The `ExternalFunctionManager` class parses command line args for running external commands but requires a missing/incomplete preceding line of code.",
    "details": [
        {
            "comment": "Creates a class \"ArgumentTransformer\" for transforming data model annotations to command line argument schema.\nUses \"argparse\" library and stores properties of data model in instance variables for further processing.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/argparse_utils.py\":0-42",
            "content": "from log_utils import logger_print\nfrom log_utils import pretty\n# from pydantic import BaseModel\nimport argparse\nfrom typing import TypeVar, Generic, Callable, Any\n# from beartype import beartype\nfrom error_utils import ErrorManager\nimport subprocess\npydantic_type_to_pytype = {\n    \"integer\": int,\n    \"number\": float,\n    \"string\": str,\n    \"boolean\": bool,\n    # fallback type: string\n}\nprop_translation_as_is = [\"default\"]\nprop_translation_table = {\n    \"enum\": \"choices\",\n    \"title\": \"help\",\n    **{e: e for e in prop_translation_as_is},\n}\nT = TypeVar(\"T\")\nimport typing\n# @beartype\n# class ExternalFunctionManager:\nclass ArgumentTransformer(Generic[T]):\n    def __init__(self, dataModel: T):\n        self.dataModel = dataModel\n        self.description = dataModel.__doc__\n        self.annotations = getattr(\n            typing, \"get_type_hints\", lambda m: m.__annotations__\n        )(self.dataModel)\n        self.schema = self.dataModel.schema()\n        self.properties = self.schema[\"properties\"]\n        self.fields = self.properties.keys()"
        },
        {
            "comment": "Setting up argument processing and handling possible errors.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/argparse_utils.py\":43-62",
            "content": "        self.cli_arguments = {}\n        self.required = self.schema.get(\"required\", [])\n        with ErrorManager(\n            default_error=f\"error on processing schema:\\n{pretty(self.schema)}\\ndataModel: {repr(self.dataModel)}\"\n        ) as ex:\n            for field, prop in self.properties.items():\n                help_info = []\n                field_lower = field.lower()\n                args = {\"required\": field in self.required}\n                pydantic_type = prop.pop(\"type\", \"unknown\")\n                pytype = pydantic_type_to_pytype.get(pydantic_type, None)\n                annotated_type = self.annotations.get(field)\n                # annotated_type = self.dataModel.__annotations__.get(field)  # .__name__?\n                # BUG: type: None\n                if annotated_type is None:\n                    logger_print(\n                        f\"Possible malformed annotation in field '{field}' of dataclass '{self.dataModel.__name__}'\",\n                        f\"Schema: {self.schema}\",\n                    )"
        },
        {
            "comment": "Appends formatted type and default value help information to list if provided. If a property key doesn't have translation, it logs a message and skips the property. If pydantic type is not present, it falls back to string type.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/argparse_utils.py\":63-81",
            "content": "                help_info.append(\n                    f\"[{'type'.center(7,' ')}]\\t{repr(annotated_type)}\"\n                    # f\"[type]\\t{getattr(annotated_type, '__name__', repr(annotated_type))}\"\n                )\n                for prop_name, prop_value in prop.items():\n                    if prop_name == \"default\":\n                        help_info.append(f\"[{'default'.center(7,' ')}]\\t{prop_value}\")\n                    translated_prop_name = prop_translation_table.get(prop_name, None)\n                    if translated_prop_name:\n                        args[translated_prop_name] = prop_value\n                    else:\n                        msg = f\"property key '{prop_name}' of field '{field}' does not have translation. skipping...\"\n                        logger_print(msg)\n                        # ex.append(msg)\n                if pytype is not None:\n                    args[\"type\"] = pytype\n                else:\n                    msg = f\"pydantic type '{pydantic_type}' does not have corresponding python type. falling back to str\""
        },
        {
            "comment": "This code adds a new field to the argparse parser, handles duplication warnings, and formats help text with line breaks.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/argparse_utils.py\":82-103",
            "content": "                    logger_print(msg)\n                    # ex.append(msg)\n                    args[\"type\"] = str\n                if field_lower in self.cli_arguments.keys():\n                    ex.append(\n                        f\"Field '{field}' is possibly duplicated in the sense of lower case '{field_lower}' within existing fields\"\n                    )\n                    continue\n                # if len(help_info) > 0:\n                #     help_info += [\"\"]\n                # ref: https://www.knowledge-repo.com/post/python/adding_newlines_to_argparse_help_text_in_python.kp\n                args[\"help\"] = \"\\n\".join([*help_info, f'{args.get(\"help\",\"\")}\\n'])\n                # args[\"help\"] = '\\n'.join([f'({\", \".join(help_info)})',f'{args.get(\"help\",\"\")}'])\n                self.cli_arguments[field_lower] = args\n            # breakpoint()\n    def parse(self):\n        argparser = argparse.ArgumentParser(description=self.description)\n        argparser.formatter_class = argparse.RawTextHelpFormatter\n        for argName, cli_arg in self.cli_arguments.items():"
        },
        {
            "comment": "This code defines a class `ExternalFunctionManager` and an inner class `ArgumentTransformer`, which is used to parse command line arguments, serialize them into a dictionary, and create an instance of the provided data model. It also provides two decorators: `answer()` and `call()`. The `answer()` decorator takes a function that accepts an instance of the data model and returns a new function that parses the arguments and calls the original function with the parsed arguments. The `call()` decorator wraps a function and ensures that the argument passed to it is an instance of the specified data model before executing the function.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/argparse_utils.py\":104-132",
            "content": "            argparser.add_argument(f\"--{argName}\", **cli_arg)\n        arguments = argparser.parse_args()\n        arguments_serialized = {}\n        for field in self.fields:\n            arguments_serialized[field] = getattr(arguments, field.lower())\n        param = self.dataModel(**arguments_serialized)\n        return param\nclass ExternalFunctionManager(ArgumentTransformer[T]):\n    def __init__(self, dataModel: T, cmd: str):\n        super().__init__(dataModel)\n        self.cmd = cmd.strip()\n    def answer(self, func: Callable[[T], Any]):\n        def decorated_func():\n            param = self.parse()\n            return func(param)\n        return decorated_func\n    def call(self, func: Callable[[T], Any]):\n        def decorated_func(param: T):\n            assert isinstance(\n                param, self.dataModel\n            ), f\"Invalid parameter: {param}\\nShould be of type {self.dataModel}\"\n            arguments = []\n            for argName, argVal in param.dict().items():\n                argNameLower = argName.lower()"
        },
        {
            "comment": "The code is creating a command using argument names and values, then running a subprocess with that command. It logs the command, process output, and any errors if the return code is not 0. This function decorates other functions to run external commands.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/argparse_utils.py\":133-156",
            "content": "                pytype = self.cli_arguments[argName][\"type\"]\n                argVal = pytype(argVal)\n                if not isinstance(argVal, str):\n                    argVal = str(argVal)\n                arguments.extend([f\"--{argNameLower}\", argVal])\n            proc_cmd = self.cmd.split() + arguments\n            logger_print(\"calling:\", proc_cmd, \" \".join(proc_cmd))\n            proc = subprocess.run(\n                proc_cmd, shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE\n            )\n            logger_print(\"process output:\", proc.stdout.decode())\n            logger_print(\"process stderr:\", proc.stderr.decode())\n            if proc.returncode != 0:\n                logger_print(\"invalid process return code:\", proc.returncode)\n            return func(param)\n        return decorated_func\n# from shared_datamodels import ConflictRefinerParams\n# conflictRefinerManager = ExternalFunctionManager(\n#     dataModel=ConflictRefinerParams,\n#     cmd=\"conda run -n docplex --live-stream --no-capture-output python conflict_utils.py\","
        },
        {
            "comment": "This code seems to be missing or incomplete. It appears there should be a line of code preceding this one, but it is not present in the snippet provided.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/argparse_utils.py\":157-157",
            "content": "# )"
        }
    ]
}