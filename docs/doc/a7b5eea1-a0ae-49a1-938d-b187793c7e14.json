{
    "summary": "The code defines classes and methods for DotEnv parsing, ensuring dataclass compatibility and retrieving configuration using specific manager and data classes.",
    "details": [
        {
            "comment": "The code defines a class EnvBaseModel that inherits from BaseModel and provides tools for parsing shell and config file environment variables. It also sets the suspicious threshold as 3, indicating the maximum number of typographical errors allowed to raise a suspicious detection hint. The minimum length of an envname is set at 6 characters, below which it would be considered suspicious. The function getBaseModelPropertyKeys returns the list of properties in a BaseModel object.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/config_utils.py\":0-34",
            "content": "from log_utils import logger_print\n\"\"\"\nReserved shell env keyword:\n    DOTENV\nReserved commandline argument:\n    --dotenv\nReserved config file env keyword:\n    IMPORT\nDescription:\n    Provide tools for parsing shell and config file environment variables.\n\"\"\"\nimport os\nimport Levenshtein  # to detect suspicious mistypings\nfrom pydantic import BaseModel\nfrom exception_utils import ExceptionManager\nfrom typing import Union\nfrom argparse_utils import ArgumentTransformer\nsuspicous_threshold = 3\n# for names in between environ attribute name definitions, this would be suspicious_threshold*2\n# raise exception for any shell env var that is not present but similar to predefined vars, with hints of suspected predefined var name.\n# raise exception for any shell/file config env var that is not present in the predefined vars, with hints of suspected predefined var name.\nmin_envname_length_threshold = 6\ndef getBaseModelPropertyKeys(bm: BaseModel):\n    return list(bm.schema()[\"properties\"].keys())\nclass EnvBaseModel(BaseModel):"
        },
        {
            "comment": "The code defines three methods: 'reduce', 'diff', and a class-specific constructor '__new__'. The 'reduce' method checks the model's base classes and returns the first parent datamodel. The 'diff' method returns a dictionary containing properties with non-default values. The '__new__' method iterates over the base model property keys, checks if they are uppercase, and appends an exception message if not.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/config_utils.py\":35-62",
            "content": "    def reduce(self):\n        \"\"\"\n        Returns self as if parsed by first parent datamodel\n        \"\"\"\n        bases = self.__class__.__bases__\n        for base in bases:\n            if issubclass(base, Union[EnvBaseModel, BaseModel]):\n                return base.parse_obj(self)\n        raise Exception(\n            \"Cannot reduce model: %s\\nBases: %s\" % (self.__class__.__name__, bases)\n        )\n    def diff(self):\n        \"\"\"\n        Returns a dictionary which contains all properties with non-default values\n        \"\"\"\n        return {k: v for k, v in self.dict().items() if v != self.__fields__[k].default}\n    def __new__(cls, *args, **kwargs):\n        upper_prop_keys = set()\n        with ExceptionManager() as exc_manager:\n            for key in getBaseModelPropertyKeys(cls):\n                upper_key = key.upper()\n                keylen = len(key)\n                if upper_key != key:\n                    exc_manager.append(\"Key %s is not upper case.\" % key)\n                elif upper_key in upper_prop_keys:"
        },
        {
            "comment": "This code checks for duplicate properties, property key length, and similarity between keys to avoid potential issues in the configuration. It appends exception messages to a list if any issues are found, otherwise adds the upper_key to upper_prop_keys set.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/config_utils.py\":63-81",
            "content": "                    exc_manager.append(\n                        \"Duplicate property %s in definition of %s\"\n                        % (upper_prop_keys, cls.__name__)\n                    )\n                elif keylen < min_envname_length_threshold:\n                    exc_manager.append(\n                        \"Key %s (length: %d) is too short.\\nMinimum length: %d\"\n                        % (key, keylen, min_envname_length_threshold)\n                    )\n                else:\n                    for uk in upper_prop_keys:\n                        edit_distance = Levenshtein.distance(uk, upper_key)\n                        min_upper_prop_key_st = suspicous_threshold * 2\n                        if edit_distance < min_upper_prop_key_st:\n                            exc_manager.append(\n                                \"Key %s has too little distance to another key %s.\\nMinimum distance: %d\"\n                                % (upper_key, uk, min_upper_prop_key_st)\n                            )\n                    upper_prop_keys.add(upper_key)"
        },
        {
            "comment": "The code defines three classes: `DotEnvBaseModel`, `ArgumentEnv`, and `ShellEnv`. They inherit from `EnvBaseModel` and use the `Field` class from `pydantic` library. The code also includes a method called `load()` that is used to load the DotEnv file into an instance of either `ArgumentEnv` or `ShellEnv`. The method creates an instance of `ArgumentTransformer` and uses it to parse the DotEnv file, then returns the parameter values. If any exceptions occur during this process, they are handled by an `ExceptionManager`.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/config_utils.py\":82-119",
            "content": "        # new_cls = super().__new__(cls)\n        # new_cls.__annotations__ = cls.__annotations__\n        # breakpoint()\n        # return new_cls\n        return super().__new__(cls)\nfrom pydantic import Field\nclass DotEnvBaseModel(EnvBaseModel):\n    DOTENV: Union[str, None] = Field(default=None, title=\"A single DotEnv file path\")\nclass ArgumentEnv(DotEnvBaseModel):\n    @classmethod\n    def load(cls):\n        trans = ArgumentTransformer(cls)\n        param = trans.parse()\n        return param\nclass ShellEnv(DotEnvBaseModel):\n    @classmethod\n    def load(cls):\n        pks = getBaseModelPropertyKeys(cls)\n        shellenvs = os.environ\n        envs = {}\n        with ExceptionManager() as exc_manager:\n            for k, v in shellenvs.items():\n                if len(pks) == 0:\n                    break\n                uk = k.upper()\n                pks.sort(key=lambda pk: Levenshtein.distance(pk, uk))\n                fpk = pks[0]\n                if fpk == uk:\n                    envs[fpk] = v\n                    pks.remove(fpk)"
        },
        {
            "comment": "This code is a Python class definition for the \"DotEnv\" class. It uses the \"EnvBaseModel\" as its base and has a \"IMPORT\" attribute, which is a field used to specify import file paths separated by spaces. The class also includes properties and methods to resolve imported files and check for suspicious environment variables.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/config_utils.py\":120-151",
            "content": "                else:\n                    ed = Levenshtein.distance(fpk, uk)\n                    if ed < suspicous_threshold:\n                        exc_manager.append(\n                            f\"Suspicious shell env var found.\\n'{k}' (upper case: '{uk}') is similar to '{fpk}' (edit distance: {ed})\"\n                        )\n                    else:\n                        continue  # do nothing. just ignore excessive shell environment vars.\n        return cls(**envs)\nfrom dotenv import dotenv_values\nclass DotEnv(EnvBaseModel):\n    IMPORT: str = Field(\n        default=\"\",\n        title=\"DotEnv import file path list which shall be separated by space\",\n    )\n    @property\n    def import_fpaths(self):\n        imp_fpaths = self.IMPORT.strip().split()\n        imp_fpaths = [fp.strip() for fp in imp_fpaths]\n        imp_fpaths = [fp for fp in imp_fpaths if len(fp) > 0]\n        return imp_fpaths\n    def resolve_import_graph(self):\n        import_fpaths = self.import_fpaths\n        resolv = []\n        for fpath in import_fpaths:"
        },
        {
            "comment": "This code is responsible for resolving and preloading configuration files in a specific order, ensuring that environment variables from these files are properly assigned to their corresponding properties in the schema. It also handles exceptions and ensures that only matching properties are set, avoiding any potential conflicts or overwrites.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/config_utils.py\":152-185",
            "content": "            subdot = self.preload(fpath, envs={}, _cls=DotEnv)\n            resolv.append(fpath)\n            subresolv = subdot.resolve_import_graph()\n            resolv.extend(subresolv)\n        resolv.reverse()\n        ret = []\n        for res in resolv:\n            if res not in ret:\n                ret.append(res)\n        ret.reverse()\n        return ret\n    @classmethod\n    def preload(cls, fpath: str, _cls=None):\n        assert os.path.isfile(fpath), \"File %s does not exist\" % fpath\n        envs = {}\n        if _cls is None:\n            _cls = cls\n        vals = dotenv_values(fpath)\n        prop_keys = getBaseModelPropertyKeys(cls)\n        with ExceptionManager() as exc_manager:\n            for k, v in vals.items():\n                if len(prop_keys) == 0:\n                    break\n                uk = k.upper()\n                if uk not in prop_keys:\n                    exc_manager.append(\n                        \"No matching property '%s' in schema %s\" % (uk, prop_keys)\n                    )\n                    for pk in prop_keys:"
        },
        {
            "comment": "This code snippet defines a class called \"DotEnv\" and a method within it, which compares two strings (uk and pk) using the Levenshtein distance algorithm. If the distance is less than or equal to the suspicious threshold, it appends a message to a list. Otherwise, it removes the first string from a set of property keys and assigns a value to the remaining key in an \"env\" dictionary. The DotEnv class also has a method called \"presolve_import_graph\", which preloads a file and returns an import graph. Additionally, there is another class called EnvManager, which defines properties (shellEnv, dotEnv, argumentEnv), but only loads them without any specific actions.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/config_utils.py\":186-221",
            "content": "                        if Levenshtein.distance(uk, pk) <= suspicous_threshold:\n                            exc_manager.append(f\"'{uk}' could be: '{pk}'\")\n                else:\n                    prop_keys.remove(uk)\n                    envs[uk] = v\n        return _cls(**envs)\n    @classmethod\n    def presolve_import_graph(cls, fpath: str):\n        pre_inst = cls.preload(fpath, _cls=DotEnv)\n        imp_graph = pre_inst.resolve_import_graph()\n        return imp_graph\n    @classmethod\n    def load(cls, fpath: str):\n        inst = cls.preload(fpath)\n        inst_envs = inst.diff()\n        envs = {}\n        for imp_fpath in inst.resolve_import_graph():\n            envs.update(cls.preload(imp_fpath).diff())\n        envs.update(inst_envs)\n        return cls(**envs)\nclass EnvManager:\n    shellEnv: ShellEnv\n    dotEnv: DotEnv\n    argumentEnv: ArgumentEnv\n    @classmethod\n    def load(cls):\n        cls.shellEnv: ShellEnv\n        cls.dotEnv: DotEnv\n        cls.argumentEnv: ArgumentEnv\n        shellEnvInst = cls.shellEnv.load()"
        },
        {
            "comment": "This code loads environment variables from different sources: shell, command line arguments, and dotenv files. It uses the EnvConfig class to parse and store the variables, with case-insensitive property names. The load method returns a dictionary of loaded environment variables in the order of priority: shell, command line arguments, and dotenv files.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/config_utils.py\":222-257",
            "content": "        params = shellEnvInst.dict()\n        argumentEnvInst = cls.argumentEnv.load()\n        params.update(argumentEnvInst.diff())\n        _dotenv = shellEnvInst.DOTENV\n        if _dotenv is not None:\n            dotEnvInst = cls.dotEnv.load(_dotenv)\n            params.update(dotEnvInst.diff())\n        return params\nclass EnvConfig:\n    \"\"\"\n    This class is used to parse and store the environment variables from file or environment variables.\n    Property names are case-insensitive.\n    \"\"\"\n    manager_cls: EnvManager\n    data_cls: EnvBaseModel\n    @classmethod\n    def load(cls):\n        \"\"\"\n        Load environment variables.\n        Load sequence:\n            Environment variables from shell\\n\n            Commandline arguments\\n\n            Dotenv file and subsequent imported files\n        \"\"\"\n        params = cls.manager_cls.load()\n        data_inst = cls.data_cls(**params)\n        logger_print(\n            \"Loaded environment variables:\",\n            *[f\"{k}:\\t{repr(v)}\" for k, v in data_inst.dict().items()],"
        },
        {
            "comment": "The code defines a function called `checkReservedKeywordNameClash`, which takes two dataclasses as parameters: `reserved_dataclass` and `env_class`. It retrieves the fields set by annotations of both dataclasses using the `getFieldsSetByAnnotation` function, then checks for any intersection between the sets. If there is a clash, it raises an exception with the clashing field names. The code also includes a function called `extendEnvClass`, which extends the `env_class` by adding fields from the `reserved_dataclass`. The `__annotations__` attribute is not modified directly to maintain compatibility with older Python versions.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/config_utils.py\":258-291",
            "content": "        )\n        return data_inst\ndef getFieldsSetByAnnotation(dataclass: EnvBaseModel):\n    anno = dataclass.__annotations__\n    fields = anno.keys()\n    return set(fields)\ndef checkReservedKeywordNameClash(\n    reserved_dataclass: EnvBaseModel, env_class: EnvBaseModel\n):\n    reserved = getFieldsSetByAnnotation(reserved_dataclass)\n    env = getFieldsSetByAnnotation(env_class)\n    isect = reserved.intersection(env)\n    if isect != set():\n        with ExceptionManager(\n            default_error=f\"Dataclass '{env_class.__name__}' has name clash on reserved dataclass '{reserved_dataclass.__name__}'\"\n        ) as em:\n            for field in isect:\n                em.append(f\"Field '{field}' clashed.\")\ndef extendEnvClass(\n    reserved_dataclass: Union[ShellEnv, ArgumentEnv, DotEnv], env_class: EnvBaseModel\n):\n    # do not change the annotations in the class definition.\n    checkReservedKeywordNameClash(reserved_dataclass, env_class)\n    class extended_env_class(reserved_dataclass, env_class):\n        ...\n    extended_env_class.__annotations__ = {"
        },
        {
            "comment": "Creates a class extending EnvManager with three classes for shell, dotenv, and argument environments, using the given env_class.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/config_utils.py\":292-324",
            "content": "        **reserved_dataclass.__annotations__,\n        **env_class.__annotations__,\n    }\n    # breakpoint()\n    extended_env_class.__doc__ = env_class.__doc__\n    return extended_env_class\n# def getShellEnvClass(env_class: EnvBaseModel):\n#     shell_env_class = extendEnvClass(ShellEnv, env_class)\n#     return shell_env_class\n# def getDotEnvClass(env_class: EnvBaseModel):\n#     dot_env_class = extendEnvClass(DotEnv, env_class)\n#     return dot_env_class\n# def getArgumentEnvClass(env_class: EnvBaseModel):\n#     argument_env_class = extendEnvClass(ArgumentEnv, env_class)\n#     return argument_env_class\ndef getEnvManagerClass(env_class: EnvBaseModel):\n    class env_manager_class(EnvManager):\n        shellEnv = extendEnvClass(ShellEnv, env_class)\n        dotEnv = extendEnvClass(DotEnv, env_class)\n        argumentEnv = extendEnvClass(ArgumentEnv, env_class)\n        # shellEnv = getShellEnvClass(env_class)\n        # dotEnv = getDotEnvClass(env_class)\n        # argumentEnv = getArgumentEnvClass(env_class)\n    return env_manager_class"
        },
        {
            "comment": "This code defines two functions, `getEnvConfigClass` and `getConfig`. The first function creates a new class that inherits from `EnvConfig` with specific manager and data classes. The second function returns the loaded configuration for the given data class using the previously created custom config class.",
            "location": "\"/media/root/Toshiba XG3/works/git_atomic_commit/docs/src/config_utils.py\":327-343",
            "content": "def getEnvConfigClass(env_class: EnvBaseModel):\n    class env_config_class(EnvConfig):\n        manager_cls = getEnvManagerClass(env_class)\n        data_cls = env_class\n    return env_config_class\nfrom typing import TypeVar\nT = TypeVar(\"T\")\ndef getConfig(data_cls: T) -> T:\n    envConfigClass = getEnvConfigClass(data_cls)\n    config: T = envConfigClass.load()\n    return config"
        }
    ]
}